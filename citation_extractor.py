#!/usr/bin/env python3
"""
Citation Extractor for Academic Research

Identifies and extracts structured citation data from academic texts.
Works with markdown files generated by the PDF processor.

Usage:
    python citation_extractor.py --input <markdown_file> --output <output_directory>
"""

import argparse
import re
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict


@dataclass
class Citation:
    """Structured citation data."""
    raw_text: str
    citation_type: str  # 'book', 'article', 'archival', 'interview', etc.
    authors: List[str]
    year: Optional[str]
    title: Optional[str]
    publisher: Optional[str]
    location: Optional[str]
    source: Optional[str]  # journal, archive, etc.
    url: Optional[str]
    notes: Optional[str]
    confidence: float  # 0.0 to 1.0


class CitationExtractor:
    """Extract and parse citations from academic texts."""
    
    def __init__(self):
        # Citation patterns (we'll build these progressively)
        self.patterns = {
            'book': self._compile_book_patterns(),
            'article': self._compile_article_patterns(),
            'interview': self._compile_interview_patterns(),
            'archival': self._compile_archival_patterns(),
            'online': self._compile_online_patterns(),
        }
        
        # Statistics
        self.stats = {
            'total_lines': 0,
            'citations_found': 0,
            'by_type': {},
        }
    
    def _compile_book_patterns(self) -> List[re.Pattern]:
        """Regex patterns for book citations."""
        return [
            # Pattern: Author. Year. Title. Location: Publisher.
            re.compile(
                r'^-?\s*([A-ZČŠŽÁÉÍÓÚÝŇĎŤĽ][^\d\.]+?)\.\s*'  # Author
                r'(\d{4})\.\s*'  # Year
                r'([^\.]+?)\.\s*'  # Title
                r'([^:]+):\s*'  # Location
                r'([^\.]+)\.',  # Publisher
                re.MULTILINE | re.UNICODE
            ),
        ]
    
    def _compile_article_patterns(self) -> List[re.Pattern]:
        """Regex patterns for journal articles."""
        return [
            # Pattern: Author. Year. "Title." Journal volume(issue): pages.
            re.compile(
                r'^-?\s*([A-ZČŠŽÁÉÍÓÚÝŇĎŤĽ][^\d\.]+?)\.\s*'  # Author
                r'(\d{4})\.\s*'  # Year
                r'"([^"]+)"\.\s*'  # Title in quotes
                r'([^\d]+?)\s+'  # Journal name
                r'(\d+)\s*'  # Volume
                r'(?:\((\d+)\))?\s*:\s*'  # Optional issue
                r'(\d+-\d+)',  # Pages
                re.MULTILINE | re.UNICODE
            ),
        ]
    
    def _compile_interview_patterns(self) -> List[re.Pattern]:
        """Regex patterns for interviews."""
        return [
            # Pattern: Name. Year. Interview by Interviewer. Location, date.
            re.compile(
                r'^-?\s*([A-ZČŠŽÁÉÍÓÚÝŇĎŤĽ][^\d\.]+?)\.\s*'  # Interviewee
                r'(\d{4})\.\s*'  # Year
                r'(?:Interview|Rozhovor)\s+'  # Interview keyword
                r'(?:by|s)\s+'  # 'by' or 's' (Slovak)
                r'([^\.]+?)\.\s*'  # Interviewer
                r'([^,]+),\s*'  # Location
                r'([^\.]+)\.',  # Date
                re.MULTILINE | re.UNICODE | re.IGNORECASE
            ),
        ]
    
    def _compile_archival_patterns(self) -> List[re.Pattern]:
        """Regex patterns for archival documents."""
        return [
            # Pattern: Archive name, location. Date range.
            re.compile(
                r'^-?\s*([Aa]rchív|[Ll]ibrary)[^\.]+\.\s*'  # Archive identifier
                r'(\d{4}(?:-\d{4})?)',  # Date range
                re.MULTILINE | re.UNICODE
            ),
        ]
    
    def _compile_online_patterns(self) -> List[re.Pattern]:
        """Regex patterns for online sources."""
        return [
            # Pattern: Any line with https:// or http://
            re.compile(
                r'(https?://[^\s]+)',
                re.UNICODE
            ),
        ]
    
    def extract_from_file(self, filepath: Path) -> List[Citation]:
        """Extract citations from a markdown file."""
        print(f"\nExtracting citations from: {filepath.name}")
        
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Skip metadata section
        content = self._skip_metadata(content)
        
        citations = []
        lines = content.split('\n')
        self.stats['total_lines'] = len(lines)
        
        # Process line by line and in sections
        current_section = None
        
        for line in lines:
            # Track section headers for context
            if line.startswith('#'):
                current_section = line.strip()
                continue
            
            # Skip empty lines
            if not line.strip():
                continue
            
            # Try to extract citation
            citation = self._parse_line(line, current_section)
            if citation:
                citations.append(citation)
                self.stats['citations_found'] += 1
                
                # Update type statistics
                ctype = citation.citation_type
                self.stats['by_type'][ctype] = self.stats['by_type'].get(ctype, 0) + 1
        
        return citations
    
    def _skip_metadata(self, content: str) -> str:
        """Skip the metadata section at the beginning."""
        parts = content.split('## Extracted Text', 1)
        if len(parts) == 2:
            return parts[1]
        return content
    
    def _parse_line(self, line: str, section: Optional[str]) -> Optional[Citation]:
        """Try to parse a line as a citation."""
        
        # Skip lines that are clearly not citations
        if len(line) < 20:
            return None
        
        # Try each pattern type
        for citation_type, patterns in self.patterns.items():
            for pattern in patterns:
                match = pattern.search(line)
                if match:
                    return self._build_citation(line, citation_type, match, section)
        
        # If it starts with '- ' and has reasonable length, might be a citation
        # Store as 'unclassified' for manual review
        if line.strip().startswith('-') and len(line) > 30:
            return Citation(
                raw_text=line.strip(),
                citation_type='unclassified',
                authors=[],
                year=self._extract_year(line),
                title=None,
                publisher=None,
                location=None,
                source=None,
                url=self._extract_url(line),
                notes=section,
                confidence=0.3
            )
        
        return None
    
    def _build_citation(self, line: str, ctype: str, match: re.Match, 
                       section: Optional[str]) -> Citation:
        """Build a Citation object from regex match."""
        
        if ctype == 'book':
            return Citation(
                raw_text=line.strip(),
                citation_type='book',
                authors=self._parse_authors(match.group(1)),
                year=match.group(2),
                title=match.group(3).strip(),
                location=match.group(4).strip(),
                publisher=match.group(5).strip(),
                source=None,
                url=None,
                notes=section,
                confidence=0.9
            )
        
        elif ctype == 'article':
            return Citation(
                raw_text=line.strip(),
                citation_type='article',
                authors=self._parse_authors(match.group(1)),
                year=match.group(2),
                title=match.group(3).strip(),
                source=match.group(4).strip(),
                publisher=None,
                location=None,
                url=None,
                notes=f"{section} | Vol {match.group(5)} ({match.group(6)}): {match.group(7)}",
                confidence=0.9
            )
        
        elif ctype == 'interview':
            return Citation(
                raw_text=line.strip(),
                citation_type='interview',
                authors=self._parse_authors(match.group(1)),
                year=match.group(2),
                title=f"Interview with {match.group(1)}",
                location=match.group(4).strip(),
                publisher=None,
                source=f"Interviewed by {match.group(3)}",
                url=None,
                notes=f"{section} | {match.group(5)}",
                confidence=0.85
            )
        
        elif ctype == 'archival':
            return Citation(
                raw_text=line.strip(),
                citation_type='archival',
                authors=[],
                year=match.group(2),
                title=None,
                location=None,
                publisher=None,
                source=line.strip(),
                url=None,
                notes=section,
                confidence=0.7
            )
        
        elif ctype == 'online':
            return Citation(
                raw_text=line.strip(),
                citation_type='online',
                authors=[],
                year=self._extract_year(line),
                title=None,
                location=None,
                publisher=None,
                source=None,
                url=match.group(1),
                notes=section,
                confidence=0.8
            )
        
        return None
    
    def _parse_authors(self, author_string: str) -> List[str]:
        """Parse author names from string."""
        # Handle multiple authors separated by 'and', 'a', ','
        authors = re.split(r'\s+(?:and|a)\s+|,\s*(?:and|a)\s+', author_string)
        return [a.strip() for a in authors if a.strip()]
    
    def _extract_year(self, text: str) -> Optional[str]:
        """Try to extract a year from text."""
        match = re.search(r'\b(19\d{2}|20\d{2})\b', text)
        return match.group(1) if match else None
    
    def _extract_url(self, text: str) -> Optional[str]:
        """Try to extract a URL from text."""
        match = re.search(r'https?://[^\s]+', text)
        return match.group(0) if match else None
    
    def save_citations(self, citations: List[Citation], output_dir: Path, 
                      source_filename: str):
        """Save extracted citations in multiple formats."""
        
        output_dir.mkdir(parents=True, exist_ok=True)
        base_name = Path(source_filename).stem
        
        # 1. Save as JSON (structured data)
        json_path = output_dir / f"{base_name}_citations.json"
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump([asdict(c) for c in citations], f, indent=2, ensure_ascii=False)
        
        # 2. Save as markdown (human-readable)
        md_path = output_dir / f"{base_name}_citations.md"
        self._generate_markdown_report(citations, md_path, source_filename)
        
        # 3. Save statistics
        stats_path = output_dir / f"{base_name}_stats.json"
        with open(stats_path, 'w', encoding='utf-8') as f:
            json.dump(self.stats, f, indent=2)
        
        print(f"\n  ✓ Saved citations to:")
        print(f"    - JSON: {json_path}")
        print(f"    - Markdown: {md_path}")
        print(f"    - Stats: {stats_path}")
    
    def _generate_markdown_report(self, citations: List[Citation], 
                                  output_path: Path, source_filename: str):
        """Generate a markdown report of citations."""
        
        with open(output_path, 'w', encoding='utf-8') as f:
            # Header
            f.write(f"# Citation Analysis: {source_filename}\n\n")
            f.write(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            f.write(f"**Total Citations Found:** {len(citations)}\n\n")
            
            # Statistics by type
            f.write("## Citations by Type\n\n")
            for ctype, count in sorted(self.stats['by_type'].items()):
                f.write(f"- **{ctype.title()}:** {count}\n")
            f.write("\n")
            
            # Group citations by type
            by_type = {}
            for citation in citations:
                ctype = citation.citation_type
                if ctype not in by_type:
                    by_type[ctype] = []
                by_type[ctype].append(citation)
            
            # Write each type section
            for ctype in sorted(by_type.keys()):
                f.write(f"## {ctype.title()} Citations\n\n")
                
                for citation in by_type[ctype]:
                    f.write(f"### {citation.title or 'Untitled'}\n\n")
                    
                    if citation.authors:
                        f.write(f"**Authors:** {', '.join(citation.authors)}\n\n")
                    
                    if citation.year:
                        f.write(f"**Year:** {citation.year}\n\n")
                    
                    if citation.location:
                        f.write(f"**Location:** {citation.location}\n\n")
                    
                    if citation.publisher:
                        f.write(f"**Publisher:** {citation.publisher}\n\n")
                    
                    if citation.source:
                        f.write(f"**Source:** {citation.source}\n\n")
                    
                    if citation.url:
                        f.write(f"**URL:** {citation.url}\n\n")
                    
                    f.write(f"**Confidence:** {citation.confidence:.0%}\n\n")
                    
                    f.write(f"**Raw Text:**\n```\n{citation.raw_text}\n```\n\n")
                    f.write("---\n\n")
    
    def print_summary(self):
        """Print extraction summary."""
        print(f"\n{'='*60}")
        print("Citation Extraction Summary")
        print(f"{'='*60}")
        print(f"\nTotal lines processed: {self.stats['total_lines']}")
        print(f"Citations found: {self.stats['citations_found']}")
        
        if self.stats['by_type']:
            print("\nBreakdown by type:")
            for ctype, count in sorted(self.stats['by_type'].items()):
                print(f"  - {ctype.title()}: {count}")
        
        print(f"\n{'='*60}\n")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Extract structured citation data from academic texts',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python citation_extractor.py --input extracted.md --output ./citations
  python citation_extractor.py -i paper.md -o ./output
        """
    )
    
    parser.add_argument(
        '--input', '-i',
        required=True,
        help='Markdown file to process (from PDF processor)'
    )
    
    parser.add_argument(
        '--output', '-o',
        required=True,
        help='Directory for output files'
    )
    
    args = parser.parse_args()
    
    # Validate input
    input_path = Path(args.input)
    if not input_path.exists():
        print(f"Error: Input file not found: {input_path}")
        exit(1)
    
    # Create extractor and process
    extractor = CitationExtractor()
    citations = extractor.extract_from_file(input_path)
    
    # Save results
    output_dir = Path(args.output)
    extractor.save_citations(citations, output_dir, input_path.name)
    
    # Print summary
    extractor.print_summary()
    
    exit(0)


if __name__ == '__main__':
    main()